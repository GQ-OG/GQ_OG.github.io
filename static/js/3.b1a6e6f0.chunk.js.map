{"version":3,"sources":["../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../node_modules/@babel/runtime/regenerator/index.js","../node_modules/regenerator-runtime/runtime.js","../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/react-hook-form/dist/react-hook-form.es.js"],"names":["_slicedToArray","arr","i","Array","isArray","Symbol","iterator","Object","prototype","toString","call","_arr","_n","_d","_e","undefined","_s","_i","next","done","push","value","length","err","TypeError","module","exports","runtime","Op","hasOwn","hasOwnProperty","$Symbol","iteratorSymbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","wrap","innerFn","outerFn","self","tryLocsList","protoGenerator","Generator","generator","create","context","Context","_invoke","state","GenStateSuspendedStart","method","arg","GenStateExecuting","Error","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","GenStateSuspendedYield","makeInvokeMethod","fn","obj","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","previousPromise","callInvokeWithMethodAndArg","Promise","resolve","reject","invoke","result","__await","then","unwrapped","error","info","resultName","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","constructor","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","iter","keys","object","key","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","Function","_toConsumableArray","arr2","from","_defineProperty","defineProperty","enumerable","configurable","writable","VALIDATION_MODE","onBlur","onChange","onSubmit","UNDEFINED","EVENTS","BLUR","CHANGE","INPUT","INPUT_VALIDATION_RULES","max","min","maxLength","minLength","pattern","required","validate","isUndefined","val","isNullOrUndefined","isObjectType","isObject","reIsDeepProp","reIsPlainProp","rePropName","reEscapeChar","reIsUint","isIndex","test","stringToPath","string","replace","match","number","quote","set","path","index","tempPath","isKey","lastIndex","newValue","objValue","combineFieldValues","data","entries","reduce","previous","indexOf","assign","removeAllEventListeners","ref","validateWithStateUpdate","removeEventListener","isRadioInput","isCheckBoxInput","isDetached","element","HTMLElement","nodeType","Node","DOCUMENT_NODE","parentNode","defaultReturn","isValid","getRadioValue","options","checked","getMultipleSelectValue","filter","selected","map","isMultipleSelect","isEmptyString","defaultResult","validResult","getCheckboxValue","valueAttribute","attributes","getFieldValue","fields","files","field","getFieldsValues","isEmptyObject","isSameError","message","isRegex","RegExp","getValueAndMessage","validationData","isPureObject","isString","displayNativeError","nativeValidation","setCustomValidity","isFunction","isBoolean","getValidateError","nativeError","isStringValue","appendErrors","validateAllFieldCriteria","errors","types","validateField","fieldsRef","a","current","isRadio","isCheckBox","isRadioOrCheckbox","isEmpty","bind","appendErrorsCurry","typedName","maxValue","maxMessage","minValue","minMessage","valueNumber","parseFloat","exceedMax","exceedMin","Date","maxLengthValue","maxLengthMessage","minLengthValue","minLengthMessage","inputLength","patternValue","patternMessage","fieldValue","validateRef","validateError","validateFunctions","validateResult","validationResult","parseErrorSchema","inner","validateWithSchema","validationSchema","validationSchemaOption","fieldErrors","get","defaultValue","split","Boolean","getDefaultValue","defaultValues","isPrimitive","getPath$1","parentPath","flatArray","list","b","concat","getPath","item","pathWithIndex","objectValue","pathWithKey","assignWatchFields","fieldValues","fieldName","watchFields","combinedDefaultValues","add","omitValidFields","errorFields","validFieldNames","some","validFieldName","__rest","s","e","t","p","getOwnPropertySymbols","propertyIsEnumerable","omitObject","_a","modeChecker","mode","isOnSubmit","isOnBlur","isOnChange","useRef","React","useState","useCallback","useEffect","createContext","useForm","reValidateMode","submitFocusError","abortEarly","validateCriteriaMode","errorsRef","touchedFieldsRef","Set","watchFieldsRef","dirtyFieldsRef","fieldsWithValidationRef","validFieldsRef","isValidSchemaResult","defaultInputValuesRef","defaultValuesRef","isUnMount","isWatchAllRef","isSubmittedRef","isDirtyRef","submitCountRef","isSubmittingRef","validateAndUpdateStateRef","_render","isWindowUndefined","window","isWeb","document","isProxyEnabled","readFormState","dirty","isSubmitted","submitCount","touched","isSubmitting","isReValidateOnBlur","isReValidateOnSubmit","validationSchemaOptionRef","shouldInfoValid","combineErrorsRef","render","validateFieldCurry","validateWithSchemaCurry","renderBaseOnError","shouldRender","reRender","validFields","fieldsWithValidation","isFieldValid","isFormValid","currentFieldError","existFieldError","has","isManual","shouldUpdateWithError","delete","setFieldValue","rawValue","radioRef","selectRef","includes","checkboxRef","setDirty","isDirty","isDirtyChanged","size","setInternalValue","executeValidation","executeSchemaValidation","payload","isMultipleFields","names","triggerValidation","all","every","setValue","shouldValidate","target","currentError","isBlurEvent","shouldSkipValidation","shouldUpdateDirty","shouldUpdateState","resetFieldRef","removeEventListenerAndRef","forceDelete","mutationWatcher","option","disconnect","splice","findRemovedFieldAndRemoveListener","setInternalError","preventRender","registerIntoFieldsRef","validateOptions","console","warn","fieldAttributes","currentField","find","onDetachCallback","observer","MutationObserver","observe","childList","subtree","onDomRemove","isEmptyDefaultValues","fieldToAttachListener","rules","source","attachNativeValidation","validateAndStateUpdate","addEventListener","attachEventListeners","handleSubmit","callback","preventDefault","persist","output","resolvedPrevious","fieldError","focus","fieldsKeyValue","closest","getValues","outputValues","nest","formState","register","refOrValidateRule","validationOptions","unregister","watch","fieldNames","clearError","setError","Proxy","prop"],"mappings":"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","file":"static/js/3.b1a6e6f0.chunk.js","sourcesContent":["import arrayWithHoles from \"./arrayWithHoles\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit\";\nimport nonIterableRest from \"./nonIterableRest\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}","module.exports = require(\"regenerator-runtime\");\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}","export default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}","export default function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import * as React from 'react';\nimport { createContext, useContext, useRef as useRef$1, createElement } from 'react';\n\nconst VALIDATION_MODE = {\r\n    onBlur: 'onBlur',\r\n    onChange: 'onChange',\r\n    onSubmit: 'onSubmit',\r\n};\r\nconst RADIO_INPUT = 'radio';\r\nconst UNDEFINED = 'undefined';\r\nconst EVENTS = {\r\n    BLUR: 'blur',\r\n    CHANGE: 'change',\r\n    INPUT: 'input',\r\n};\r\nconst INPUT_VALIDATION_RULES = {\r\n    max: 'max',\r\n    min: 'min',\r\n    maxLength: 'maxLength',\r\n    minLength: 'minLength',\r\n    pattern: 'pattern',\r\n    required: 'required',\r\n    validate: 'validate',\r\n};\n\nfunction attachEventListeners({ field, validateAndStateUpdate, isRadioOrCheckbox, }) {\r\n    const { ref } = field;\r\n    if (!ref.addEventListener) {\r\n        return;\r\n    }\r\n    ref.addEventListener(isRadioOrCheckbox ? EVENTS.CHANGE : EVENTS.INPUT, validateAndStateUpdate);\r\n    ref.addEventListener(EVENTS.BLUR, validateAndStateUpdate);\r\n}\n\nvar isUndefined = (val) => val === undefined;\n\nvar isNullOrUndefined = (value) => value === null || isUndefined(value);\n\nvar isArray = (value) => Array.isArray(value);\n\nconst isObjectType = (value) => typeof value === 'object';\r\nvar isObject = (value) => !isNullOrUndefined(value) && !isArray(value) && isObjectType(value);\n\nconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\r\nconst reIsPlainProp = /^\\w*$/;\r\nconst rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\r\nconst reEscapeChar = /\\\\(\\\\)?/g;\r\nconst reIsUint = /^(?:0|[1-9]\\d*)$/;\r\nfunction isIndex(value) {\r\n    return reIsUint.test(value) && value > -1;\r\n}\r\nfunction isKey(value) {\r\n    if (isArray(value)) {\r\n        return false;\r\n    }\r\n    return reIsPlainProp.test(value) || !reIsDeepProp.test(value);\r\n}\r\nconst stringToPath = (string) => {\r\n    const result = [];\r\n    string.replace(rePropName, (match, number, quote, string) => {\r\n        result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);\r\n    });\r\n    return result;\r\n};\r\nfunction set(object, path, value) {\r\n    let index = -1;\r\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\r\n    const length = tempPath.length;\r\n    const lastIndex = length - 1;\r\n    while (++index < length) {\r\n        const key = tempPath[index];\r\n        let newValue = value;\r\n        if (index !== lastIndex) {\r\n            const objValue = object[key];\r\n            newValue =\r\n                isObject(objValue) || isArray(objValue)\r\n                    ? objValue\r\n                    : isIndex(tempPath[index + 1])\r\n                        ? []\r\n                        : {};\r\n        }\r\n        object[key] = newValue;\r\n        object = object[key];\r\n    }\r\n    return object;\r\n}\n\nvar combineFieldValues = (data) => Object.entries(data).reduce((previous, [key, value]) => {\r\n    if (!!key.match(/\\[.+\\]/gi) || key.indexOf('.') > 0) {\r\n        set(previous, key, value);\r\n        return previous;\r\n    }\r\n    return Object.assign(Object.assign({}, previous), { [key]: value });\r\n}, {});\n\nvar removeAllEventListeners = (ref, validateWithStateUpdate) => {\r\n    if (!ref.removeEventListener) {\r\n        return;\r\n    }\r\n    ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\r\n    ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\r\n    ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\r\n};\n\nvar isRadioInput = (type) => type === RADIO_INPUT;\n\nvar isCheckBoxInput = (type) => type === 'checkbox';\n\nfunction isDetached(element) {\r\n    if (!element) {\r\n        return true;\r\n    }\r\n    if (!(element instanceof HTMLElement) ||\r\n        element.nodeType === Node.DOCUMENT_NODE) {\r\n        return false;\r\n    }\r\n    return isDetached(element.parentNode);\r\n}\n\nfunction findRemovedFieldAndRemoveListener(fields, validateWithStateUpdate = () => { }, field, forceDelete) {\r\n    if (!field) {\r\n        return;\r\n    }\r\n    const { ref, mutationWatcher } = field;\r\n    if (!ref.type || !fields[ref.name]) {\r\n        return;\r\n    }\r\n    const { name, type } = ref;\r\n    const options = fields[name];\r\n    if (isRadioInput(type) || isCheckBoxInput(type)) {\r\n        if (isArray(options) && options.length) {\r\n            options.forEach(({ ref }, index) => {\r\n                const option = options[index];\r\n                if ((option && isDetached(ref)) || forceDelete) {\r\n                    const mutationWatcher = option.mutationWatcher;\r\n                    removeAllEventListeners(option, validateWithStateUpdate);\r\n                    if (mutationWatcher) {\r\n                        mutationWatcher.disconnect();\r\n                    }\r\n                    options.splice(index, 1);\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            delete fields[name];\r\n        }\r\n    }\r\n    else if (isDetached(ref) || forceDelete) {\r\n        removeAllEventListeners(ref, validateWithStateUpdate);\r\n        if (mutationWatcher) {\r\n            mutationWatcher.disconnect();\r\n        }\r\n        delete fields[name];\r\n    }\r\n}\n\nconst defaultReturn = {\r\n    isValid: false,\r\n    value: '',\r\n};\r\nvar getRadioValue = (options) => isArray(options)\r\n    ? options.reduce((previous, { ref: { checked, value } }) => checked\r\n        ? {\r\n            isValid: true,\r\n            value,\r\n        }\r\n        : previous, defaultReturn)\r\n    : defaultReturn;\n\nvar getMultipleSelectValue = (options) => [...options]\r\n    .filter(({ selected }) => selected)\r\n    .map(({ value }) => value);\n\nvar isMultipleSelect = (type) => type === 'select-multiple';\n\nvar isEmptyString = (value) => value === '';\n\nconst defaultResult = {\r\n    value: false,\r\n    isValid: false,\r\n};\r\nconst validResult = { value: true, isValid: true };\r\nvar getCheckboxValue = (options) => {\r\n    if (isArray(options)) {\r\n        if (options.length > 1) {\r\n            const values = options\r\n                .filter(({ ref: { checked } }) => checked)\r\n                .map(({ ref: { value } }) => value);\r\n            return { value: values, isValid: !!values.length };\r\n        }\r\n        const { checked, value, attributes: { value: valueAttribute }, } = options[0].ref;\r\n        return checked\r\n            ? valueAttribute\r\n                ? isUndefined(value) || isEmptyString(value)\r\n                    ? validResult\r\n                    : { value: value, isValid: true }\r\n                : validResult\r\n            : defaultResult;\r\n    }\r\n    return defaultResult;\r\n};\n\nfunction getFieldValue(fields, ref) {\r\n    const { type, name, options, value, files } = ref;\r\n    const field = fields[name];\r\n    if (type === 'file') {\r\n        return files;\r\n    }\r\n    if (isRadioInput(type)) {\r\n        return field ? getRadioValue(field.options).value : '';\r\n    }\r\n    if (isMultipleSelect(type)) {\r\n        return getMultipleSelectValue(options);\r\n    }\r\n    if (isCheckBoxInput(type)) {\r\n        return field ? getCheckboxValue(field.options).value : false;\r\n    }\r\n    return value;\r\n}\n\nvar getFieldsValues = (fields) => Object.values(fields).reduce((previous, { ref, ref: { name } }) => (Object.assign(Object.assign({}, previous), { [name]: getFieldValue(fields, ref) })), {});\n\nvar isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;\n\nvar isSameError = (error, type, message) => isObject(error) && error.type === type && error.message === message;\n\nfunction shouldUpdateWithError({ errors, name, error, validFields, fieldsWithValidation, }) {\r\n    const isFieldValid = isEmptyObject(error);\r\n    const isFormValid = isEmptyObject(errors);\r\n    const currentFieldError = error[name];\r\n    const existFieldError = errors[name];\r\n    if ((isFieldValid && validFields.has(name)) ||\r\n        (existFieldError && existFieldError.isManual)) {\r\n        return false;\r\n    }\r\n    if (isFormValid !== isFieldValid ||\r\n        (!isFormValid && !existFieldError) ||\r\n        (isFieldValid && fieldsWithValidation.has(name) && !validFields.has(name))) {\r\n        return true;\r\n    }\r\n    return (currentFieldError &&\r\n        !isSameError(existFieldError, currentFieldError.type, currentFieldError.message));\r\n}\n\nvar isRegex = (value) => value instanceof RegExp;\n\nvar getValueAndMessage = (validationData) => {\r\n    const isPureObject = isObject(validationData) && !isRegex(validationData);\r\n    return {\r\n        value: isPureObject\r\n            ? validationData.value\r\n            : validationData,\r\n        message: isPureObject\r\n            ? validationData.message\r\n            : '',\r\n    };\r\n};\n\nvar isString = (value) => typeof value === 'string';\n\nvar displayNativeError = (nativeValidation, ref, message) => {\r\n    if (nativeValidation && isString(message)) {\r\n        ref.setCustomValidity(message);\r\n    }\r\n};\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nfunction getValidateError(result, ref, nativeError, type = 'validate') {\r\n    const isStringValue = isString(result);\r\n    if (isStringValue || (isBoolean(result) && !result)) {\r\n        const message = isStringValue ? result : '';\r\n        const error = {\r\n            type,\r\n            message,\r\n            ref,\r\n        };\r\n        nativeError(message);\r\n        return error;\r\n    }\r\n}\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => {\r\n    if (!validateAllFieldCriteria) {\r\n        return {};\r\n    }\r\n    const error = errors[name] || { types: {} };\r\n    return Object.assign(Object.assign({}, error), { types: Object.assign(Object.assign({}, error.types), { [type]: message || true }) });\r\n};\n\nvar validateField = async (fieldsRef, nativeValidation, validateAllFieldCriteria, { ref, ref: { type, value, name }, options, required, maxLength, minLength, min, max, pattern, validate, }) => {\r\n    const fields = fieldsRef.current;\r\n    const error = {};\r\n    const isRadio = isRadioInput(type);\r\n    const isCheckBox = isCheckBoxInput(type);\r\n    const isRadioOrCheckbox = isRadio || isCheckBox;\r\n    const isEmpty = isEmptyString(value);\r\n    const nativeError = displayNativeError.bind(null, nativeValidation, ref);\r\n    const typedName = name;\r\n    const appendErrorsCurry = appendErrors.bind(null, typedName, validateAllFieldCriteria, error);\r\n    if (required &&\r\n        ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value))) ||\r\n            (isCheckBox && !getCheckboxValue(options).isValid) ||\r\n            (isRadio && !getRadioValue(options).isValid))) {\r\n        const message = isString(required)\r\n            ? required\r\n            : getValueAndMessage(required).message;\r\n        error[typedName] = Object.assign({ type: INPUT_VALIDATION_RULES.required, message, ref: isRadioOrCheckbox ? fields[typedName].options[0].ref : ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));\r\n        nativeError(message);\r\n        if (!validateAllFieldCriteria) {\r\n            return error;\r\n        }\r\n    }\r\n    if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {\r\n        let exceedMax;\r\n        let exceedMin;\r\n        const { value: maxValue, message: maxMessage } = getValueAndMessage(max);\r\n        const { value: minValue, message: minMessage } = getValueAndMessage(min);\r\n        if (type === 'number') {\r\n            const valueNumber = parseFloat(value);\r\n            if (!isNullOrUndefined(maxValue)) {\r\n                exceedMax = valueNumber > maxValue;\r\n            }\r\n            if (!isNullOrUndefined(minValue)) {\r\n                exceedMin = valueNumber < minValue;\r\n            }\r\n        }\r\n        else {\r\n            if (isString(maxValue)) {\r\n                exceedMax = new Date(value) > new Date(maxValue);\r\n            }\r\n            if (isString(minValue)) {\r\n                exceedMin = new Date(value) < new Date(minValue);\r\n            }\r\n        }\r\n        if (exceedMax || exceedMin) {\r\n            const message = exceedMax ? maxMessage : minMessage;\r\n            error[typedName] = Object.assign({ type: exceedMax\r\n                    ? INPUT_VALIDATION_RULES.max\r\n                    : INPUT_VALIDATION_RULES.min, message,\r\n                ref }, (exceedMax\r\n                ? appendErrorsCurry(INPUT_VALIDATION_RULES.max, message)\r\n                : appendErrorsCurry(INPUT_VALIDATION_RULES.min, message)));\r\n            nativeError(message);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(value) && !isEmpty && (maxLength || minLength)) {\r\n        const { value: maxLengthValue, message: maxLengthMessage, } = getValueAndMessage(maxLength);\r\n        const { value: minLengthValue, message: minLengthMessage, } = getValueAndMessage(minLength);\r\n        const inputLength = value.toString().length;\r\n        const exceedMax = maxLength && inputLength > maxLengthValue;\r\n        const exceedMin = minLength && inputLength < minLengthValue;\r\n        if (exceedMax || exceedMin) {\r\n            const message = exceedMax ? maxLengthMessage : minLengthMessage;\r\n            error[typedName] = Object.assign({ type: exceedMax\r\n                    ? INPUT_VALIDATION_RULES.maxLength\r\n                    : INPUT_VALIDATION_RULES.minLength, message,\r\n                ref }, (exceedMax\r\n                ? appendErrorsCurry(INPUT_VALIDATION_RULES.maxLength, message)\r\n                : appendErrorsCurry(INPUT_VALIDATION_RULES.minLength, message)));\r\n            nativeError(message);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (pattern && !isEmpty) {\r\n        const { value: patternValue, message: patternMessage } = getValueAndMessage(pattern);\r\n        if (isRegex(patternValue) && !patternValue.test(value)) {\r\n            error[typedName] = Object.assign({ type: INPUT_VALIDATION_RULES.pattern, message: patternMessage, ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, patternMessage));\r\n            nativeError(patternMessage);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (validate) {\r\n        const fieldValue = getFieldValue(fields, ref);\r\n        const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\r\n        if (isFunction(validate)) {\r\n            const result = await validate(fieldValue);\r\n            const validateError = getValidateError(result, validateRef, nativeError);\r\n            if (validateError) {\r\n                error[typedName] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n        else if (isObject(validate)) {\r\n            const validateFunctions = Object.entries(validate);\r\n            const validationResult = await new Promise((resolve) => {\r\n                validateFunctions.reduce(async (previous, [key, validate], index) => {\r\n                    if ((!isEmptyObject(await previous) && !validateAllFieldCriteria) ||\r\n                        !isFunction(validate)) {\r\n                        return resolve(previous);\r\n                    }\r\n                    let result;\r\n                    const validateResult = await validate(fieldValue);\r\n                    const validateError = getValidateError(validateResult, validateRef, nativeError, key);\r\n                    if (validateError) {\r\n                        result = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\r\n                        if (validateAllFieldCriteria) {\r\n                            error[typedName] = result;\r\n                        }\r\n                    }\r\n                    else {\r\n                        result = previous;\r\n                    }\r\n                    return validateFunctions.length - 1 === index\r\n                        ? resolve(result)\r\n                        : result;\r\n                }, {});\r\n            });\r\n            if (!isEmptyObject(validationResult)) {\r\n                error[typedName] = Object.assign({ ref: validateRef }, validationResult);\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (nativeValidation) {\r\n        ref.setCustomValidity('');\r\n    }\r\n    return error;\r\n};\n\nconst parseErrorSchema = (error, validateAllFieldCriteria) => isArray(error.inner)\r\n    ? error.inner.reduce((previous, { path, message, type }) => (Object.assign(Object.assign({}, previous), (previous[path] && validateAllFieldCriteria\r\n        ? {\r\n            [path]: appendErrors(path, validateAllFieldCriteria, previous, type, message),\r\n        }\r\n        : {\r\n            [path]: Object.assign({ message,\r\n                type }, (validateAllFieldCriteria\r\n                ? {\r\n                    types: { [type]: message || true },\r\n                }\r\n                : {})),\r\n        }))), {})\r\n    : {\r\n        [error.path]: { message: error.message, type: error.type },\r\n    };\r\nasync function validateWithSchema(validationSchema, validationSchemaOption, validateAllFieldCriteria, data) {\r\n    try {\r\n        return {\r\n            result: await validationSchema.validate(data, validationSchemaOption),\r\n            fieldErrors: {},\r\n        };\r\n    }\r\n    catch (e) {\r\n        return {\r\n            result: {},\r\n            fieldErrors: parseErrorSchema(e, validateAllFieldCriteria),\r\n        };\r\n    }\r\n}\n\nfunction attachNativeValidation(ref, rules) {\r\n    Object.entries(rules).forEach(([key, value]) => {\r\n        if (key === INPUT_VALIDATION_RULES.pattern && isRegex(value)) {\r\n            ref[key] = value.source;\r\n        }\r\n        else {\r\n            ref[key] = key === INPUT_VALIDATION_RULES.pattern || value;\r\n        }\r\n    });\r\n}\n\nvar get = (obj, path, defaultValue) => {\r\n    const result = path\r\n        .split(/[,[\\].]+?/)\r\n        .filter(Boolean)\r\n        .reduce((result, key) => (isNullOrUndefined(result) ? result : result[key]), obj);\r\n    return isUndefined(result) || result === obj ? defaultValue : result;\r\n};\n\nvar getDefaultValue = (defaultValues, name, defaultValue) => isUndefined(defaultValues[name])\r\n    ? get(defaultValues, name, defaultValue)\r\n    : defaultValues[name];\n\nfunction flatArray(list) {\r\n    return list.reduce((a, b) => a.concat(isArray(b) ? flatArray(b) : b), []);\r\n}\n\nvar isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);\n\nconst getPath = (path, values) => isArray(values)\r\n    ? values.map((item, index) => {\r\n        const pathWithIndex = `${path}[${index}]`;\r\n        return isPrimitive(item) ? pathWithIndex : getPath(pathWithIndex, item);\r\n    })\r\n    : Object.entries(values).map(([key, objectValue]) => {\r\n        const pathWithKey = `${path}.${key}`;\r\n        return isPrimitive(objectValue)\r\n            ? pathWithKey\r\n            : getPath(pathWithKey, objectValue);\r\n    });\r\nvar getPath$1 = (parentPath, value) => flatArray(getPath(parentPath, value));\n\nvar assignWatchFields = (fieldValues, fieldName, watchFields, combinedDefaultValues) => {\r\n    let value;\r\n    if (isEmptyObject(fieldValues)) {\r\n        value = undefined;\r\n    }\r\n    else if (!isUndefined(fieldValues[fieldName])) {\r\n        watchFields.add(fieldName);\r\n        value = fieldValues[fieldName];\r\n    }\r\n    else {\r\n        value = get(combineFieldValues(fieldValues), fieldName);\r\n        if (!isUndefined(value)) {\r\n            getPath$1(fieldName, value).forEach(name => watchFields.add(name));\r\n        }\r\n    }\r\n    return isUndefined(value)\r\n        ? isObject(combinedDefaultValues)\r\n            ? getDefaultValue(combinedDefaultValues, fieldName)\r\n            : combinedDefaultValues\r\n        : value;\r\n};\n\nvar omitValidFields = (errorFields, validFieldNames) => Object.entries(errorFields).reduce((previous, [name, error]) => validFieldNames.some(validFieldName => validFieldName === name)\r\n    ? previous\r\n    : Object.assign(Object.assign({}, previous), { [name]: error }), {});\n\nfunction onDomRemove(element, onDetachCallback) {\r\n    const observer = new MutationObserver(() => {\r\n        if (isDetached(element)) {\r\n            observer.disconnect();\r\n            onDetachCallback();\r\n        }\r\n    });\r\n    observer.observe(window.document, {\r\n        childList: true,\r\n        subtree: true,\r\n    });\r\n    return observer;\r\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\nconst omitObject = (obj, key) => {\r\n    const _a = key, omitted = obj[_a], rest = __rest(obj, [typeof _a === \"symbol\" ? _a : _a + \"\"]);\r\n    return rest;\r\n};\n\nvar modeChecker = (mode) => ({\r\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\r\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\r\n    isOnChange: mode === VALIDATION_MODE.onChange,\r\n});\n\nconst { useRef, useState, useCallback, useEffect } = React;\r\nfunction useForm({ mode = VALIDATION_MODE.onSubmit, reValidateMode = VALIDATION_MODE.onChange, validationSchema, defaultValues = {}, nativeValidation = false, submitFocusError = true, validationSchemaOption = { abortEarly: false }, validateCriteriaMode, } = {}) {\r\n    const fieldsRef = useRef({});\r\n    const validateAllFieldCriteria = validateCriteriaMode === 'all';\r\n    const errorsRef = useRef({});\r\n    const touchedFieldsRef = useRef(new Set());\r\n    const watchFieldsRef = useRef(new Set());\r\n    const dirtyFieldsRef = useRef(new Set());\r\n    const fieldsWithValidationRef = useRef(new Set());\r\n    const validFieldsRef = useRef(new Set());\r\n    const isValidSchemaResult = useRef(true);\r\n    const defaultInputValuesRef = useRef({});\r\n    const defaultValuesRef = useRef(defaultValues);\r\n    const isUnMount = useRef(false);\r\n    const isWatchAllRef = useRef(false);\r\n    const isSubmittedRef = useRef(false);\r\n    const isDirtyRef = useRef(false);\r\n    const submitCountRef = useRef(0);\r\n    const isSubmittingRef = useRef(false);\r\n    const validateAndUpdateStateRef = useRef();\r\n    const [, _render] = useState();\r\n    const { isOnBlur, isOnSubmit } = useRef(modeChecker(mode)).current;\r\n    const isWindowUndefined = typeof window === UNDEFINED;\r\n    const isWeb = typeof document !== UNDEFINED &&\r\n        !isWindowUndefined &&\r\n        !isUndefined(window.HTMLElement);\r\n    const isProxyEnabled = !isWindowUndefined && 'Proxy' in window;\r\n    const readFormState = useRef({\r\n        dirty: !isProxyEnabled,\r\n        isSubmitted: isOnSubmit,\r\n        submitCount: !isProxyEnabled,\r\n        touched: !isProxyEnabled,\r\n        isSubmitting: !isProxyEnabled,\r\n        isValid: !isProxyEnabled,\r\n    });\r\n    const { isOnBlur: isReValidateOnBlur, isOnSubmit: isReValidateOnSubmit, } = useRef(modeChecker(reValidateMode)).current;\r\n    const validationSchemaOptionRef = useRef(validationSchemaOption);\r\n    let shouldInfoValid = true;\r\n    defaultValuesRef.current = defaultValues;\r\n    const combineErrorsRef = (data) => (Object.assign(Object.assign({}, errorsRef.current), data));\r\n    const render = useCallback(() => {\r\n        if (!isUnMount.current) {\r\n            _render({});\r\n        }\r\n    }, []);\r\n    const validateFieldCurry = useCallback(validateField.bind(null, fieldsRef, nativeValidation, validateAllFieldCriteria), []);\r\n    const validateWithSchemaCurry = useCallback(validateWithSchema.bind(null, validationSchema, validationSchemaOptionRef.current, validateAllFieldCriteria), [validationSchema]);\r\n    const renderBaseOnError = useCallback((name, error, shouldRender) => {\r\n        let reRender = shouldRender ||\r\n            shouldUpdateWithError({\r\n                errors: errorsRef.current,\r\n                error,\r\n                name,\r\n                validFields: validFieldsRef.current,\r\n                fieldsWithValidation: fieldsWithValidationRef.current,\r\n            });\r\n        if (isEmptyObject(error)) {\r\n            if (fieldsWithValidationRef.current.has(name) || validationSchema) {\r\n                validFieldsRef.current.add(name);\r\n                reRender = reRender || errorsRef.current[name];\r\n            }\r\n            errorsRef.current = omitObject(errorsRef.current, name);\r\n        }\r\n        else {\r\n            validFieldsRef.current.delete(name);\r\n            reRender = reRender || !errorsRef.current[name];\r\n        }\r\n        errorsRef.current = combineErrorsRef(error);\r\n        if (reRender) {\r\n            render();\r\n            return true;\r\n        }\r\n    }, [render, validationSchema]);\r\n    const setFieldValue = useCallback((name, rawValue) => {\r\n        const field = fieldsRef.current[name];\r\n        if (!field) {\r\n            return false;\r\n        }\r\n        const ref = field.ref;\r\n        const { type } = ref;\r\n        const options = field.options;\r\n        const value = isWeb &&\r\n            ref instanceof window.HTMLElement &&\r\n            isNullOrUndefined(rawValue)\r\n            ? ''\r\n            : rawValue;\r\n        if (isRadioInput(type) && options) {\r\n            options.forEach(({ ref: radioRef }) => (radioRef.checked = radioRef.value === value));\r\n        }\r\n        else if (isMultipleSelect(type)) {\r\n            [...ref.options].forEach(selectRef => (selectRef.selected = value.includes(selectRef.value)));\r\n        }\r\n        else if (isCheckBoxInput(type) && options) {\r\n            options.length > 1\r\n                ? options.forEach(({ ref: checkboxRef }) => (checkboxRef.checked = value.includes(checkboxRef.value)))\r\n                : (options[0].ref.checked = !!value);\r\n        }\r\n        else {\r\n            ref.value = value;\r\n        }\r\n        return type;\r\n    }, [isWeb]);\r\n    const setDirty = (name) => {\r\n        if (!fieldsRef.current[name]) {\r\n            return false;\r\n        }\r\n        const isDirty = defaultInputValuesRef.current[name] !==\r\n            getFieldValue(fieldsRef.current, fieldsRef.current[name].ref);\r\n        const isDirtyChanged = dirtyFieldsRef.current.has(name) !== isDirty;\r\n        if (isDirty) {\r\n            dirtyFieldsRef.current.add(name);\r\n        }\r\n        else {\r\n            dirtyFieldsRef.current.delete(name);\r\n        }\r\n        isDirtyRef.current = !!dirtyFieldsRef.current.size;\r\n        return isDirtyChanged && readFormState.current.dirty;\r\n    };\r\n    const setInternalValue = useCallback((name, value) => {\r\n        setFieldValue(name, value);\r\n        if (setDirty(name) ||\r\n            (!touchedFieldsRef.current.has(name) && readFormState.current.touched)) {\r\n            return !!touchedFieldsRef.current.add(name);\r\n        }\r\n    }, [setFieldValue]);\r\n    const executeValidation = useCallback(async ({ name, value, }, shouldRender) => {\r\n        const field = fieldsRef.current[name];\r\n        if (!field) {\r\n            return false;\r\n        }\r\n        if (!isUndefined(value)) {\r\n            setInternalValue(name, value);\r\n        }\r\n        if (shouldRender) {\r\n            render();\r\n        }\r\n        const error = await validateFieldCurry(field);\r\n        renderBaseOnError(name, error);\r\n        return isEmptyObject(error);\r\n    }, [render, renderBaseOnError, setInternalValue, validateFieldCurry]);\r\n    const executeSchemaValidation = useCallback(async (payload, shouldRender) => {\r\n        const { fieldErrors } = await validateWithSchemaCurry(combineFieldValues(getFieldsValues(fieldsRef.current)));\r\n        const isMultipleFields = isArray(payload);\r\n        const names = isArray(payload)\r\n            ? payload.map(({ name }) => name)\r\n            : [payload.name];\r\n        const validFieldNames = names.filter(name => !fieldErrors[name]);\r\n        if (isMultipleFields) {\r\n            errorsRef.current = omitValidFields(combineErrorsRef(Object.entries(fieldErrors)\r\n                .filter(([key]) => names.includes(key))\r\n                .reduce((previous, [name, error]) => (Object.assign(Object.assign({}, previous), { [name]: error })), {})), validFieldNames);\r\n            render();\r\n        }\r\n        else {\r\n            const fieldName = names[0];\r\n            renderBaseOnError(fieldName, fieldErrors[fieldName]\r\n                ? { [fieldName]: fieldErrors[fieldName] }\r\n                : {}, shouldRender);\r\n        }\r\n        return isEmptyObject(errorsRef.current);\r\n    }, [render, renderBaseOnError, validateWithSchemaCurry]);\r\n    const triggerValidation = useCallback(async (payload, shouldRender) => {\r\n        const fields = payload || Object.keys(fieldsRef.current).map(name => ({ name }));\r\n        if (validationSchema) {\r\n            return executeSchemaValidation(fields, shouldRender);\r\n        }\r\n        if (isArray(fields)) {\r\n            const result = await Promise.all(fields.map(async (data) => await executeValidation(data, false)));\r\n            render();\r\n            return result.every(Boolean);\r\n        }\r\n        return await executeValidation(fields, shouldRender);\r\n    }, [executeSchemaValidation, executeValidation, render, validationSchema]);\r\n    const setValue = useCallback((name, value, shouldValidate) => {\r\n        const shouldRender = setInternalValue(name, value) ||\r\n            isWatchAllRef.current ||\r\n            watchFieldsRef.current.has(name);\r\n        if (shouldValidate) {\r\n            return triggerValidation({ name }, shouldRender);\r\n        }\r\n        if (shouldRender) {\r\n            render();\r\n        }\r\n        return;\r\n    }, [render, setInternalValue, triggerValidation]);\r\n    validateAndUpdateStateRef.current = validateAndUpdateStateRef.current\r\n        ? validateAndUpdateStateRef.current\r\n        : async ({ type, target }) => {\r\n            const name = target ? target.name : '';\r\n            const fields = fieldsRef.current;\r\n            const errors = errorsRef.current;\r\n            const field = fields[name];\r\n            const currentError = errors[name];\r\n            let error;\r\n            if (!field) {\r\n                return;\r\n            }\r\n            const isBlurEvent = type === EVENTS.BLUR;\r\n            const shouldSkipValidation = (isOnSubmit && !isSubmittedRef.current) ||\r\n                (isOnBlur && !isBlurEvent && !currentError) ||\r\n                (isReValidateOnBlur && !isBlurEvent && currentError) ||\r\n                (isReValidateOnSubmit && currentError);\r\n            const shouldUpdateDirty = setDirty(name);\r\n            let shouldUpdateState = isWatchAllRef.current ||\r\n                watchFieldsRef.current.has(name) ||\r\n                shouldUpdateDirty;\r\n            if (isBlurEvent &&\r\n                !touchedFieldsRef.current.has(name) &&\r\n                readFormState.current.touched) {\r\n                touchedFieldsRef.current.add(name);\r\n                shouldUpdateState = true;\r\n            }\r\n            if (shouldSkipValidation) {\r\n                return shouldUpdateState && render();\r\n            }\r\n            if (validationSchema) {\r\n                const { fieldErrors } = await validateWithSchemaCurry(combineFieldValues(getFieldsValues(fields)));\r\n                error = fieldErrors[name] ? { [name]: fieldErrors[name] } : {};\r\n                isValidSchemaResult.current = isEmptyObject(fieldErrors);\r\n            }\r\n            else {\r\n                error = await validateFieldCurry(field);\r\n            }\r\n            if (!renderBaseOnError(name, error) && shouldUpdateState) {\r\n                render();\r\n            }\r\n        };\r\n    const resetFieldRef = useCallback((name) => {\r\n        errorsRef.current = omitObject(errorsRef.current, name);\r\n        fieldsRef.current = omitObject(fieldsRef.current, name);\r\n        defaultInputValuesRef.current = omitObject(defaultInputValuesRef.current, name);\r\n        [\r\n            touchedFieldsRef,\r\n            dirtyFieldsRef,\r\n            fieldsWithValidationRef,\r\n            validFieldsRef,\r\n            watchFieldsRef,\r\n        ].forEach(data => data.current.delete(name));\r\n        if (readFormState.current.isValid || readFormState.current.touched) {\r\n            render();\r\n        }\r\n    }, [render]);\r\n    const removeEventListenerAndRef = useCallback((field, forceDelete) => {\r\n        if (!field) {\r\n            return;\r\n        }\r\n        findRemovedFieldAndRemoveListener(fieldsRef.current, validateAndUpdateStateRef.current, field, forceDelete);\r\n        resetFieldRef(field.ref.name);\r\n    }, [resetFieldRef]);\r\n    function clearError(name) {\r\n        if (isUndefined(name)) {\r\n            errorsRef.current = {};\r\n        }\r\n        else {\r\n            (isArray(name) ? name : [name]).forEach(fieldName => (errorsRef.current = omitObject(errorsRef.current, fieldName)));\r\n        }\r\n        render();\r\n    }\r\n    const setInternalError = ({ name, type, types, message, preventRender, }) => {\r\n        const errors = errorsRef.current;\r\n        if (!isSameError(errors[name], type, message)) {\r\n            errors[name] = {\r\n                type,\r\n                types,\r\n                message,\r\n                ref: {},\r\n                isManual: true,\r\n            };\r\n            if (!preventRender) {\r\n                render();\r\n            }\r\n        }\r\n    };\r\n    function setError(name, type = '', message) {\r\n        if (isString(name)) {\r\n            setInternalError(Object.assign({ name }, (isObject(type)\r\n                ? {\r\n                    types: type,\r\n                    type: '',\r\n                }\r\n                : {\r\n                    type,\r\n                    message,\r\n                })));\r\n        }\r\n        else if (isArray(name)) {\r\n            name.forEach(error => setInternalError(Object.assign(Object.assign({}, error), { preventRender: true })));\r\n            render();\r\n        }\r\n    }\r\n    function watch(fieldNames, defaultValue) {\r\n        const combinedDefaultValues = isUndefined(defaultValue)\r\n            ? isUndefined(defaultValues)\r\n                ? {}\r\n                : defaultValues\r\n            : defaultValue;\r\n        const fieldValues = getFieldsValues(fieldsRef.current);\r\n        const watchFields = watchFieldsRef.current;\r\n        if (isProxyEnabled) {\r\n            readFormState.current.dirty = true;\r\n        }\r\n        if (isString(fieldNames)) {\r\n            return assignWatchFields(fieldValues, fieldNames, watchFields, combinedDefaultValues);\r\n        }\r\n        if (isArray(fieldNames)) {\r\n            return fieldNames.reduce((previous, name) => {\r\n                let value = null;\r\n                if (isEmptyObject(fieldsRef.current) &&\r\n                    isObject(combinedDefaultValues)) {\r\n                    value = getDefaultValue(combinedDefaultValues, name);\r\n                }\r\n                else {\r\n                    value = assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues);\r\n                }\r\n                return Object.assign(Object.assign({}, previous), { [name]: value });\r\n            }, {});\r\n        }\r\n        isWatchAllRef.current = true;\r\n        return ((!isEmptyObject(fieldValues) && fieldValues) ||\r\n            defaultValue ||\r\n            defaultValues);\r\n    }\r\n    function unregister(names) {\r\n        if (!isEmptyObject(fieldsRef.current)) {\r\n            (isArray(names) ? names : [names]).forEach(fieldName => removeEventListenerAndRef(fieldsRef.current[fieldName], true));\r\n        }\r\n    }\r\n    function registerIntoFieldsRef(ref, validateOptions = {}) {\r\n        if (!ref.name) {\r\n            return console.warn('Missing name at', ref);\r\n        }\r\n        const { name, type, value } = ref;\r\n        const fieldAttributes = Object.assign({ ref }, validateOptions);\r\n        const fields = fieldsRef.current;\r\n        const isRadioOrCheckbox = isRadioInput(type) || isCheckBoxInput(type);\r\n        let currentField = fields[name];\r\n        if (isRadioOrCheckbox\r\n            ? currentField &&\r\n                isArray(currentField.options) &&\r\n                currentField.options.find(({ ref }) => value === ref.value)\r\n            : currentField) {\r\n            fields[name] = Object.assign(Object.assign({}, currentField), validateOptions);\r\n            return;\r\n        }\r\n        if (type) {\r\n            const mutationWatcher = onDomRemove(ref, () => removeEventListenerAndRef(fieldAttributes));\r\n            if (isRadioOrCheckbox) {\r\n                currentField = Object.assign({ options: [\r\n                        ...((currentField && currentField.options) || []),\r\n                        {\r\n                            ref,\r\n                            mutationWatcher,\r\n                        },\r\n                    ], ref: { type, name } }, validateOptions);\r\n            }\r\n            else {\r\n                currentField = Object.assign(Object.assign({}, fieldAttributes), { mutationWatcher });\r\n            }\r\n        }\r\n        else {\r\n            currentField = fieldAttributes;\r\n        }\r\n        fields[name] = currentField;\r\n        const isEmptyDefaultValues = isEmptyObject(defaultValuesRef.current);\r\n        if (!isEmptyDefaultValues) {\r\n            const defaultValue = getDefaultValue(defaultValuesRef.current, name);\r\n            if (!isUndefined(defaultValue)) {\r\n                setFieldValue(name, defaultValue);\r\n            }\r\n        }\r\n        if (validationSchema) {\r\n            const fieldValues = isEmptyDefaultValues\r\n                ? getFieldsValues(fields)\r\n                : defaultValuesRef.current;\r\n            if (isEmptyDefaultValues) {\r\n                fieldsWithValidationRef.current.add(name);\r\n            }\r\n            if ((!isEmptyDefaultValues && shouldInfoValid) || isEmptyDefaultValues) {\r\n                validateWithSchemaCurry(combineFieldValues(fieldValues)).then(({ fieldErrors }) => {\r\n                    if (!isEmptyObject(fieldErrors)) {\r\n                        isValidSchemaResult.current = false;\r\n                        if (shouldInfoValid) {\r\n                            render();\r\n                        }\r\n                        shouldInfoValid = false;\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        else if (!isEmptyObject(validateOptions)) {\r\n            fieldsWithValidationRef.current.add(name);\r\n            if (!isOnSubmit && readFormState.current.isValid) {\r\n                validateFieldCurry(currentField).then(error => {\r\n                    if (isEmptyObject(error)) {\r\n                        validFieldsRef.current.add(name);\r\n                    }\r\n                    else {\r\n                        if (shouldInfoValid) {\r\n                            render();\r\n                        }\r\n                        shouldInfoValid = false;\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        if (!defaultInputValuesRef.current[name]) {\r\n            defaultInputValuesRef.current[name] = getFieldValue(fields, currentField.ref);\r\n        }\r\n        if (!type) {\r\n            return;\r\n        }\r\n        const fieldToAttachListener = isRadioOrCheckbox && currentField.options\r\n            ? currentField.options[currentField.options.length - 1]\r\n            : currentField;\r\n        if (nativeValidation && validateOptions) {\r\n            attachNativeValidation(ref, validateOptions);\r\n        }\r\n        else {\r\n            attachEventListeners({\r\n                field: fieldToAttachListener,\r\n                isRadioOrCheckbox,\r\n                validateAndStateUpdate: validateAndUpdateStateRef.current,\r\n            });\r\n        }\r\n    }\r\n    function register(refOrValidateRule, validationOptions) {\r\n        if (isWindowUndefined || !refOrValidateRule) {\r\n            return;\r\n        }\r\n        if (validationOptions && isString(validationOptions.name)) {\r\n            registerIntoFieldsRef({ name: validationOptions.name }, validationOptions);\r\n            return;\r\n        }\r\n        if (isObject(refOrValidateRule) && 'name' in refOrValidateRule) {\r\n            registerIntoFieldsRef(refOrValidateRule, validationOptions);\r\n            return;\r\n        }\r\n        return (ref) => ref && registerIntoFieldsRef(ref, refOrValidateRule);\r\n    }\r\n    const handleSubmit = useCallback((callback) => async (e) => {\r\n        if (e) {\r\n            e.preventDefault();\r\n            e.persist();\r\n        }\r\n        let fieldErrors;\r\n        let fieldValues;\r\n        const fields = fieldsRef.current;\r\n        if (readFormState.current.isSubmitting) {\r\n            isSubmittingRef.current = true;\r\n            render();\r\n        }\r\n        try {\r\n            if (validationSchema) {\r\n                fieldValues = getFieldsValues(fields);\r\n                const output = await validateWithSchemaCurry(combineFieldValues(fieldValues));\r\n                errorsRef.current = output.fieldErrors;\r\n                fieldErrors = output.fieldErrors;\r\n                fieldValues = output.result;\r\n            }\r\n            else {\r\n                const { errors, values, } = await Object.values(fields).reduce(async (previous, field) => {\r\n                    if (!field) {\r\n                        return previous;\r\n                    }\r\n                    const resolvedPrevious = await previous;\r\n                    const { ref, ref: { name }, } = field;\r\n                    if (!fields[name]) {\r\n                        return Promise.resolve(resolvedPrevious);\r\n                    }\r\n                    const fieldError = await validateFieldCurry(field);\r\n                    if (fieldError[name]) {\r\n                        resolvedPrevious.errors = Object.assign(Object.assign({}, resolvedPrevious.errors), fieldError);\r\n                        validFieldsRef.current.delete(name);\r\n                        return Promise.resolve(resolvedPrevious);\r\n                    }\r\n                    if (fieldsWithValidationRef.current.has(name)) {\r\n                        validFieldsRef.current.add(name);\r\n                    }\r\n                    resolvedPrevious.values[name] = getFieldValue(fields, ref);\r\n                    return Promise.resolve(resolvedPrevious);\r\n                }, Promise.resolve({\r\n                    errors: {},\r\n                    values: {},\r\n                }));\r\n                fieldErrors = errors;\r\n                fieldValues = values;\r\n            }\r\n            if (isEmptyObject(fieldErrors)) {\r\n                errorsRef.current = {};\r\n                await callback(combineFieldValues(fieldValues), e);\r\n            }\r\n            else {\r\n                if (submitFocusError) {\r\n                    Object.keys(fieldErrors).reduce((previous, current) => {\r\n                        const field = fields[current];\r\n                        if (field && previous) {\r\n                            if (field.ref.focus) {\r\n                                field.ref.focus();\r\n                                return false;\r\n                            }\r\n                            else if (field.options) {\r\n                                field.options[0].ref.focus();\r\n                                return false;\r\n                            }\r\n                        }\r\n                        return previous;\r\n                    }, true);\r\n                }\r\n                errorsRef.current = fieldErrors;\r\n            }\r\n        }\r\n        finally {\r\n            isSubmittedRef.current = true;\r\n            isSubmittingRef.current = false;\r\n            submitCountRef.current = submitCountRef.current + 1;\r\n            render();\r\n        }\r\n    }, [\r\n        render,\r\n        submitFocusError,\r\n        validateFieldCurry,\r\n        validateWithSchemaCurry,\r\n        validationSchema,\r\n    ]);\r\n    const resetRefs = () => {\r\n        errorsRef.current = {};\r\n        defaultInputValuesRef.current = {};\r\n        touchedFieldsRef.current = new Set();\r\n        watchFieldsRef.current = new Set();\r\n        dirtyFieldsRef.current = new Set();\r\n        validFieldsRef.current = new Set();\r\n        isWatchAllRef.current = false;\r\n        isSubmittedRef.current = false;\r\n        isDirtyRef.current = false;\r\n        submitCountRef.current = 0;\r\n    };\r\n    const reset = useCallback((values) => {\r\n        const fieldsKeyValue = Object.entries(fieldsRef.current);\r\n        for (const [, value] of fieldsKeyValue) {\r\n            if (value && value.ref && value.ref.closest) {\r\n                try {\r\n                    value.ref.closest('form').reset();\r\n                    break;\r\n                }\r\n                catch (_a) { }\r\n            }\r\n        }\r\n        resetRefs();\r\n        if (values) {\r\n            fieldsKeyValue.forEach(([key]) => setFieldValue(key, getDefaultValue(values, key)));\r\n            defaultInputValuesRef.current = Object.assign({}, values);\r\n            if (readFormState.current.isValid) {\r\n                triggerValidation();\r\n            }\r\n        }\r\n        render();\r\n    }, [render, setFieldValue, triggerValidation]);\r\n    const getValues = useCallback((payload) => {\r\n        const fieldValues = getFieldsValues(fieldsRef.current);\r\n        const outputValues = isEmptyObject(fieldValues)\r\n            ? defaultValues\r\n            : fieldValues;\r\n        return payload && payload.nest\r\n            ? combineFieldValues(outputValues)\r\n            : outputValues;\r\n    }, [defaultValues]);\r\n    useEffect(() => () => {\r\n        isUnMount.current = true;\r\n        fieldsRef.current &&\r\n            Object.values(fieldsRef.current).forEach((field) => removeEventListenerAndRef(field, true));\r\n    }, [removeEventListenerAndRef]);\r\n    const formState = Object.assign({ dirty: isDirtyRef.current, isSubmitted: isSubmittedRef.current, submitCount: submitCountRef.current, touched: [...touchedFieldsRef.current], isSubmitting: isSubmittingRef.current }, (isOnSubmit\r\n        ? {\r\n            isValid: isSubmittedRef.current && isEmptyObject(errorsRef.current),\r\n        }\r\n        : {\r\n            isValid: isEmptyObject(fieldsRef.current) ||\r\n                (validationSchema\r\n                    ? isValidSchemaResult.current\r\n                    : validFieldsRef.current.size >=\r\n                        fieldsWithValidationRef.current.size &&\r\n                        isEmptyObject(errorsRef.current)),\r\n        }));\r\n    return {\r\n        register: useCallback(register, []),\r\n        unregister: useCallback(unregister, [removeEventListenerAndRef]),\r\n        handleSubmit,\r\n        watch,\r\n        reset,\r\n        clearError: useCallback(clearError, []),\r\n        setError: useCallback(setError, []),\r\n        setValue,\r\n        triggerValidation,\r\n        getValues,\r\n        errors: errorsRef.current,\r\n        formState: isProxyEnabled\r\n            ? new Proxy(formState, {\r\n                get: (obj, prop) => {\r\n                    if (prop in obj) {\r\n                        readFormState.current[prop] = true;\r\n                        return obj[prop];\r\n                    }\r\n                    return {};\r\n                },\r\n            })\r\n            : formState,\r\n    };\r\n}\n\nconst FormGlobalContext = createContext(null);\r\nfunction useFormContext() {\r\n    return useContext(FormGlobalContext);\r\n}\r\nfunction FormContext(props) {\r\n    const { children, formState, errors } = props, restMethods = __rest(props, [\"children\", \"formState\", \"errors\"]);\r\n    const restRef = useRef$1(restMethods);\r\n    return (createElement(FormGlobalContext.Provider, { value: Object.assign(Object.assign({}, restRef.current), { formState, errors }) }, children));\r\n}\n\nexport default useForm;\nexport { FormContext, useFormContext };\n"],"sourceRoot":""}