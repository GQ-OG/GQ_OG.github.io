{"version":3,"sources":["../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","page/javaDemo/index.module.scss","page/javaDemo/content.js","page/javaDemo/index.js"],"names":["_slicedToArray","arr","i","Array","isArray","Symbol","iterator","Object","prototype","toString","call","_arr","_n","_d","_e","undefined","_s","_i","next","done","push","value","length","err","TypeError","module","exports","content","title","describe","code","child","warning","Element","props","MENU","useRef","useState","visible","setVisible","useEffect","console","log","className","styles","body","body_menu","ref","menus","onClick","current","style","width","type","menuIcon","map","item","index","href","menuItem","icon","body_body","renderElement","array","list","id","list_h3","list_div1","dangerouslySetInnerHTML","__html","list_div2","hasOwnProperty","list_div3"],"mappings":"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","file":"static/js/4.e2613d99.chunk.js","sourcesContent":["import arrayWithHoles from \"./arrayWithHoles\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit\";\nimport nonIterableRest from \"./nonIterableRest\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}","// extracted by mini-css-extract-plugin\nmodule.exports = {\"body\":\"javaDemo_body__3jvEk\",\"body_body\":\"javaDemo_body_body__a4Zbi\",\"menus\":\"javaDemo_menus__33F7d\",\"menuIcon\":\"javaDemo_menuIcon__1Zt3f\",\"body_menu\":\"javaDemo_body_menu__6RQyR\",\"icon\":\"javaDemo_icon__3CYDf\",\"list\":\"javaDemo_list__27kkI\",\"list_h3\":\"javaDemo_list_h3__1kJlE\",\"list_div1\":\"javaDemo_list_div1__2MBD_\",\"list_div2\":\"javaDemo_list_div2__1tfyI\",\"list_div3\":\"javaDemo_list_div3__217ZI\",\"pad\":\"javaDemo_pad__2-eAM\",\"menuItem\":\"javaDemo_menuItem__2Om5H\",\"trueVisibe\":\"javaDemo_trueVisibe__3Agpt\",\"falseVisible\":\"javaDemo_falseVisible__1obDv\"};","import styles from './index.module.scss'\r\nexport const content = [\r\n    {\r\n        title: '抽象类',\r\n        describe: '',\r\n        code: '',\r\n        child: [{\r\n\r\n            title: '抽象类中可以添加抽象方法',\r\n            describe: '',\r\n            code: `\r\n                public String name;\r\n                public abstract void function();\r\n            `\r\n        },\r\n        {\r\n            title: '抽象类的继承',\r\n            describe: '',\r\n            code: `\r\n                public class className1 extends className{\r\n\r\n                }\r\n            `\r\n        }\r\n        ]\r\n    },\r\n    {\r\n        title: '接口的声明及实现',\r\n        describe: `\r\n            接口是抽象类的延伸,可以把它看成纯粹的抽象类,接口中所有的方法都没有方法体,\r\n            修饰符:可选,用于指定接口的访问权限,可选值为public,如果省略则使用默认的访问权限\r\n            接口名:可选,用于指定接口的访问名称,接口名必须是合法的JAVA标识符,一般情况下,要求首字母大写\r\n            extends父接口名列表:可选参数,用于指定要定义的接口继承于哪个父接口,当使用exends关键字时,父接口名为必选参数\r\n            方法:接口中的方法都是抽象方法,没有方法体\r\n        `,\r\n        code: `\r\n            [\"修饰符\"] interfac 接口名 [extends 父接口名列表]{\r\n                [public][static][fina]常量名;\r\n                [public][abstract]方法;\r\n            }\r\n        `,\r\n        warning: `\r\n            抽象类接口的多重继承,使用,分隔,弊端:产生庞大的代码量,因为实现一个接口需要实现接口中的所有方法\r\n        `,\r\n        child: [\r\n            {\r\n                title: 'implements关键字',\r\n                describe: '一个类实现一个接口可以使用implements关键字',\r\n                code: `\r\n                    public class Parallelogram drawTest{\r\n\r\n                    }\r\n                `\r\n            }\r\n        ]\r\n\r\n    },\r\n    {\r\n        title: '抽象类与接口的区别',\r\n        describe: `\r\n        1、子类只能继承一个抽象类,但可以实现多个接口\r\n        2、接口中的方法都是抽象方法,抽象类可以有非抽象方法\r\n        3、抽象类中的成员变量可以是各种类型,接口中的成员变量只能是静态常量\r\n        4、抽象类中可以有静态方法和静态代码块,接口中不可以\r\n        5、接口没有构造方法,抽象类可以有构造方法\r\n        `\r\n    },\r\n    {\r\n        title: 'final类',\r\n        describe: `\r\n        被final修饰的类不能被继承,\r\n        类中所有发给发都被隐式的设置为final的形式,但是final类中的成员变量既可以被定义为final形式,又可以被定义为非fina形式\r\n        `\r\n    },\r\n    {\r\n        title: '匿名内部类',\r\n        describe: `\r\n        匿名内部类的特点是只需使用一次,匿名内部类不能被重复使用\r\n        `,\r\n        code: `\r\n            new A(){\r\n                ..//匿名内部类的类体\r\n            }\r\n        `,\r\n        warning: `\r\n            使用匿名内部类应该遵循以下原则:\r\n            1、匿名类没有构造方法\r\n            2、匿名类不能定义静态的成员\r\n            3、匿名类不能用paivate,public,protecte,static,final,abstract等修饰\r\n            4、只可以创建一个匿名类实例\r\n        `\r\n    },\r\n    {\r\n        title: '文件的操作',\r\n        describe: `输入流抽象类有两种,分别是InputStream字节输入流和Reader字符输入流`,\r\n        code: '',\r\n        child: [\r\n            {\r\n                title: 'InputStream类',\r\n                describe: `InputStream类是字节输入流的抽象类,是所有字节输入流的父类,InputStream类的具体层次结构如下所示<br />\r\n                <p style=\"padding-left:100px\">|-AudioInputStream  </p>\r\n                <p style=\"padding-left:100px\">|-ByteArrayInputStream</p>\r\n                <p style=\"padding-left:100px\">|-FileInputStream       |-BufferedInputStream</p>\r\n                <p style=\"padding-left:100px\">|                       |-DataInputStream</p>\r\n                <p>InputStream |-FilterInputStream    -|-PushbackInputStream</p>\r\n                <p style=\"padding-left:100px\">|                       |</p>\r\n                <p style=\"padding-left:100px\">|-InputStream           |</p>\r\n                <p style=\"padding-left:100px\">|-ObjectInputStream</p>\r\n                <p style=\"padding-left:100px\">|-PipedInputStream</p>\r\n                <p style=\"padding-left:100px\">|-SequenceInputStream</p>\r\n                <p style=\"padding-left:100px\">|-StringBufferInputStream</p>\r\n                \r\n                <br />\r\n                InputStream类中所有方法遇到错误时都会引发IOException异常,该类的常用方法及说明如表所示\r\n                方法----------------------------返回值-------------------------说明\r\nread()                          int                     从输入流中读取数据的下一个字节,返回0~255范围内的int字节值,如果因为已经到达流末尾而没有可用的字节,则返回1\r\nread(byte[] b)                  int                     从输入流中读入一定长度的字节,并以整数的形式返回字节数\r\nmark(int readlimit)             void                    从输入流的当前位置放置一个标记,readlimit参数告知此输入流在标记位置失效之前允许读取的字节数\r\nreset()                         void                    将输入指针返回到当前所做的标记处\r\nskip(long n)                    lone                    跳过输入流上的n个字节并返回实际跳过的字节数\r\nmarkSupported()                 boolean                 如果当前流支持mark()/reset()操作就返回True\r\nclose()                         void                    关闭此输入流并释放与该流关联的所有系统资源\r\n                `\r\n            },\r\n            {\r\n                title: 'reader类',\r\n                describe: `\r\n                Java中的字符是以Unicode编码的,是双字节的,而InputStream类是用来处理单字节的,因此,Java提供了Reader类专门用来处理字符<br /\r\n                结构如下<br />\r\n        <p style=\"padding-left:100px\">|-BufferedReader————————————LineNumberReader</p>\r\n        <p style=\"padding-left:100px\">|-CharArrayReader</p>\r\n        <p style=\"padding-left:100px\">|-FilterReader————————————PushbackReader</p>\r\n        <p style=\"padding-left:100px\">|-InputStreamReader————————————FileReader</p>\r\n        <p>Reader  <span style=\"padding-left:50px\">|-PipedReader</span></p>\r\n        <p style=\"padding-left:100px\">|-StringReader</p>\r\n\r\n##输出流 OutputStream类,Writer类>`\r\n            },\r\n            {\r\n                title: 'BufferedInputStream类与BufferedOutputStream类',\r\n                describe: `BufferedInputStream类可以对所有InputStream的子类进行带缓冲区的包装,已达到性能的优化,\r\n                BufferedOutputStream类中的flush()方法被用来把缓冲区中的字节写入到文件中,并清空缓存`,\r\n                child: [\r\n                    {\r\n                        title: 'BufferedInputStream(InputStream in)',\r\n                        describe: '创建一个带有32个字节的缓冲输入流'\r\n                    },\r\n                    {\r\n                        title: 'BufferedInputStream(InputStream in,int size)',\r\n                        describe: '按指定的大小来创建缓冲输入流'\r\n                    },\r\n                    {\r\n                        title: 'BufferedOutputStream(OutputStream in)',\r\n                        describe: '创建一个有32个字节的缓冲输出流'\r\n                    },\r\n                    {\r\n                        title: 'BufferedOutputStream(OutputStream in,int size)',\r\n                        describe: '已指定的大小来创建缓冲输出流'\r\n                    }\r\n                ]\r\n            },\r\n            {\r\n                title: 'BufferedReader类与BufferedWrite类',\r\n                describe: 'BufferedReader类与BufferedWrite类分别继承Reader类与Writer类,这两个类同样具有内部缓冲机制,并以行为单位进行输入/输出',\r\n                child: [\r\n                    {\r\n                        title: 'BufferedReader类常用方法',\r\n                        child: [\r\n                            {\r\n                                title: 'read()',\r\n                                describe: '返回值为int型,读取单个字符'\r\n                            },\r\n                            {\r\n                                title: 'readLine()',\r\n                                describe: '读取一个文本行,并将其返回为字符串,若无数据可读,则返回null'\r\n                            }\r\n                        ]\r\n                    },\r\n                    {\r\n                        title: 'BufferedWriter类常用方法',\r\n                        child: [\r\n                            {\r\n                                title: 'write(String s,int off,int len)',\r\n                                describe: '返回void型,写入字符串的某一部分'\r\n                            },\r\n                            {\r\n                                title: 'flush()',\r\n                                describe: '返回void型,刷新该流的缓冲'\r\n                            },\r\n                            {\r\n                                title: 'newLine()',\r\n                                describe: '返回void型,写入一个行分隔符'\r\n                            }\r\n                        ]\r\n                    }\r\n                ]\r\n            }\r\n        ]\r\n    },\r\n    {\r\n        title: '多线程',\r\n        describe: 'Java提供了两种方式实现线程,分别为继承java.lang.Thread类与实现java.lang.Runnable接口',\r\n        child: [\r\n            {\r\n                title: '继承Thread类',\r\n                describe: 'Thread类是java.lang包中的一个类,Thread类的对象用来代表线程',\r\n                warning: '如果当前类不仅要继承其他类(非Thread类),还要实现多线程,继承Thread类肯定不行,在这种情况下,只能通过当前类实现Runnable接口来创建Thread类对象,语法 public class ThreadTest extends object implements Runnable',\r\n                child: [\r\n                    {\r\n                        title: 'Thread类常用的两个构造方法',\r\n                        child: [\r\n                            { title: 'public Thread()', describe: '创建一个新的线程对象' },\r\n                            { title: 'publish Thread(String threadName)', describe: '创建一个名称为threadName的线程对象' }\r\n                        ]\r\n                    },\r\n                    {\r\n                        title: 'Thread类常用的方法',\r\n                        child: [\r\n                            {\r\n                                title: 'interrupt()',\r\n                                describe: '中断线程'\r\n                            },\r\n                            {\r\n                                title: 'join()',\r\n                                describe: '等待该线程终止'\r\n                            },\r\n                            {\r\n                                title: 'join(long millis)',\r\n                                describe: '等待该线程中止的时间最长为millis毫秒'\r\n                            },\r\n                            {\r\n                                title: 'run()',\r\n                                describe: '如果该线程是使用独立的Runnable对象构造的,则调用该Runnable对象的run()方法;否则,该方法不执行任何操作并返回'\r\n                            },\r\n                            {\r\n                                title: 'setPriority(int newPriority)',\r\n                                describe: '更改线程的优先级'\r\n                            },\r\n                            {\r\n                                title: 'sleep(long millis)',\r\n                                describe: '在指定的毫秒数让当前正在执行的线程休眠(暂停执行)'\r\n                            },\r\n                            {\r\n                                title: 'start()',\r\n                                describe: '使该线程开始执行,Java虚拟机调用该线程的run()方法'\r\n                            },\r\n                            {\r\n                                title: 'yield()',\r\n                                describe: '暂停当前正在执行的线程对象,执行其他线程'\r\n                            }\r\n                        ]\r\n                    }\r\n                ],\r\n                code: `\r\n                    public class ThreadTest extends Thread{\r\n\r\n                    }\r\n                `\r\n            }\r\n        ]\r\n    }\r\n]\r\n\r\nexport const Modifier = [\r\n    { label: '公共的', value: 'public' },\r\n    { label: '可以被其子类访问,不能被外部访问', value: 'protected' },\r\n    { label: '只能在本类中访问', value: 'paivate' },\r\n    { label: '只能在本类和本类所在包中访问', value: 'default' },\r\n    {\r\n        label: 'final', value: false, describe: `\r\n        被final修饰的类不能被继承,\r\n        类中所有发给发都被隐式的设置为final的形式,但是final类中的成员变量既可以被定义为final形式,又可以被定义为非fina形式\r\n    `}\r\n]\r\n\r\nexport const type = [\r\n    // first:'基本数据类型',last:'对应的包装类'\r\n    {\r\n        first: 'byte', last: 'Byte'\r\n    },\r\n    {\r\n        first: 'int', last: 'Integer'\r\n    },\r\n    {\r\n        first: 'float', last: 'Float'\r\n    },\r\n    {\r\n        first: 'char', last: 'Character'\r\n    },\r\n    {\r\n        first: 'short', last: 'Short'\r\n    },\r\n    {\r\n        first: 'long', last: 'Lone'\r\n    },\r\n    {\r\n        first: 'double', last: 'Double'\r\n    },\r\n    {\r\n        first: 'boolean', last: 'Boolean'\r\n    }\r\n]\r\n\r\nexport const lastType = [\r\n    {\r\n        type: 'Integer',\r\n        function: [\r\n            { label: '以int型变量作为参数创建Integer对象', value: 'Integer number = new Integer(7)' },\r\n            { label: '以String型变量作为参数创建Integer对象', value: 'Integer number = new Integer(\"45\")' }\r\n        ],\r\n        mode: [\r\n            { label: '返回String型参数值的Integer对象', value: 'valueOf(String str)', return: 'Integer' },\r\n            { label: '返回与String型参数值等价的int值', value: 'parseInt(String str)', return: 'int' },\r\n            { label: '返回一个表示Integer值的String对象(可以指定进制数)', value: 'toString()', return: 'String' },\r\n            { label: '以二进制无符号整数形式返回一个整数参数的字符串表示形式', value: 'valueOf(String str)', return: 'Integer' },\r\n            { label: '返回String型参数值的Integer对象', value: 'valueOf(String str)', return: 'Integer' }\r\n        ]\r\n    }\r\n]","import React, { useState, useEffect, useLayoutEffect, useMemo,useRef } from 'react'\r\nimport { content } from './content'\r\nimport styles from './index.module.scss'\r\nimport { Icon } from 'antd'\r\nexport default function Element(props) {\r\n    const MENU = useRef()\r\n    const [arr, setArr] = useState(content)\r\n    const [visible,setVisible] = useState(true)\r\n    const handleType = () => {\r\n        console.log(MENU)\r\n        if(visible){\r\n            MENU.current.style.width = '50px'\r\n        }\r\n        else{\r\n            MENU.current.style.width = '150px'\r\n        }\r\n        setVisible(!visible)\r\n    }\r\n    useEffect(() => {\r\n        console.log(content, '......')\r\n    }, [])\r\n    const renderElement = (array) => {\r\n        let res = array.map((item, index) => {\r\n            if (item) {\r\n                // 判断是否存在\r\n                if (typeof (item) === 'object') {\r\n                    // 判断是否为对象\r\n                    return (\r\n                        <div className={styles.list} id={index}>\r\n                            <h3 className={styles.list_h3}>{item.title}</h3>\r\n                            <div className={styles.list_div1} dangerouslySetInnerHTML={{__html:item.describe}}></div>\r\n                            <div className={styles.list_div2}>{item.code}</div>\r\n                            {\r\n                                item.hasOwnProperty('warning') &&\r\n                                <div className={styles.list_div3}>{item.warning}</div>\r\n                            }\r\n                            {\r\n                                item.child && renderElement(item.child)\r\n                            }\r\n                        </div>\r\n                    )\r\n                }\r\n            }\r\n        })\r\n        return res\r\n    }\r\n    const renderMenu = (array) => {\r\n        const res = arr.map((item, index) => {\r\n            return <div><a href={`#${index}`}>\r\n                <p className={styles.menuItem}>{item.title}</p>\r\n                <Icon className={styles.icon} type={'right'}/>\r\n            </a></div>\r\n        })\r\n        return res\r\n    }\r\n    return (\r\n        <div className={styles.body}>\r\n            <div className={styles.body_menu} ref={MENU}>\r\n                <div className={styles.menus} onClick={handleType}>\r\n                <Icon type={visible?'fast-backward':'fast-forward'} className={styles.menuIcon}/>\r\n                </div>\r\n                {\r\n                    renderMenu(content)\r\n                }\r\n            </div>\r\n            <div className={styles.body_body}>\r\n                {\r\n                    renderElement(content)\r\n                }\r\n            </div>\r\n        </div>\r\n    )\r\n}"],"sourceRoot":""}